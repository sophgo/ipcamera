#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>
#include <linux/fb.h>
#include <sys/ioctl.h>
#include <stdbool.h>
#include <errno.h>
#include <linux/input.h>

#include "linux/cvi_common.h"
#include <linux/cvi_comm_mipi_tx.h>
#include "cvi_mipi_tx.h"

#include "dsi_hx8394_evb.h"

#include "lvgl/lvgl.h"
#include "lvgl/demos/lv_demos.h"

#define PANEL_WIDTH    720
#define PANEL_HEIGHT   320 //1280
#define BITS_PER_PIXEL 32

#define DEBOUNCE_TIME_MS 50 // 定义消抖时间为50毫秒
#define MOUSE_BTN_DOWN 1
#define MOUSE_BTN_UP 0

#define PWM_CHIP 4 // PWM6
#define PWM_NUM  2

int fbfd = 0;
static int fd_mouse;
static struct timeval last_key_time = {0, 0};
static lv_indev_t *indev_mouse;


const uint8_t mouse_cursor_icon_map[] = {
    0x19, 0x19, 0x19, 0xb8, 0x1e, 0x1e, 0x1e, 0xc8, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x48, 0x48, 0xcc, 0xb2, 0xb2, 0xb2, 0xff, 0x3a, 0x3a, 0x3a, 0xcc, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3b, 0x3b, 0x3b, 0xc8, 0xf6, 0xf6, 0xf6, 0xff, 0xdc, 0xdc, 0xdc, 0xff, 0x43, 0x43, 0x43, 0xe0, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3b, 0x3b, 0x3b, 0xcb, 0xe6, 0xe6, 0xe6, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xe5, 0xe5, 0xe5, 0xff, 0x59, 0x59, 0x59, 0xf3, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3c, 0x3c, 0x3c, 0xcb, 0xe9, 0xe9, 0xe9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf5, 0xf5, 0xf5, 0xff, 0x72, 0x72, 0x72, 0xff, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3d, 0x3d, 0x3d, 0xcb, 0xe9, 0xe9, 0xe9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8a, 0x8a, 0x8a, 0xff, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x99, 0x99, 0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3e, 0x3e, 0x3e, 0xcb, 0xe9, 0xe9, 0xe9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa2, 0xa2, 0xa2, 0xff, 0x13, 0x13, 0x13, 0xab, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0x3f, 0x3f, 0xcb, 0xe9, 0xe9, 0xe9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb7, 0xb7, 0xb7, 0xff, 0x1f, 0x1f, 0x1f, 0xbb, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0x41, 0x41, 0xcc, 0xea, 0xea, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xca, 0xca, 0xca, 0xff, 0x3d, 0x3d, 0x3d, 0xd8, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0x41, 0x41, 0xcc, 0xea, 0xea, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0xde, 0xde, 0xff, 0x56, 0x56, 0x56, 0xef, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00,
    0x42, 0x42, 0x42, 0xcc, 0xea, 0xea, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf3, 0xf3, 0xff, 0x76, 0x76, 0x76, 0xff, 0x00, 0x00, 0x00, 0x6b,
    0x43, 0x43, 0x43, 0xcc, 0xea, 0xea, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xce, 0xce, 0xce, 0xff, 0x80, 0x80, 0x80, 0xf7, 0x74, 0x74, 0x74, 0xf8, 0x6d, 0x6d, 0x6d, 0xfb, 0x72, 0x72, 0x72, 0xf8, 0x57, 0x57, 0x57, 0xff, 0x0c, 0x0c, 0x0c, 0xb3,
    0x44, 0x44, 0x44, 0xcc, 0xeb, 0xeb, 0xeb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfb, 0xfb, 0xfb, 0xff, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0xc9, 0xc9, 0xff, 0x13, 0x13, 0x13, 0xb7, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x0c, 0x29, 0x29, 0x29, 0x07,
    0x45, 0x45, 0x45, 0xcc, 0xe8, 0xe8, 0xe8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd9, 0xd9, 0xd9, 0xff, 0x5e, 0x5e, 0x5e, 0xff, 0xe2, 0xe2, 0xe2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x62, 0x62, 0xf0, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x45, 0x45, 0x45, 0xcc, 0xf9, 0xf9, 0xf9, 0xff, 0xec, 0xec, 0xec, 0xff, 0x4a, 0x4a, 0x4a, 0xd8, 0x00, 0x00, 0x00, 0x78, 0x8a, 0x8a, 0x8a, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xc3, 0xc3, 0xff, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x58, 0x58, 0x58, 0xd3, 0xd9, 0xd9, 0xd9, 0xff, 0x5e, 0x5e, 0x5e, 0xef, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x3b, 0x3b, 0xc7, 0xe9, 0xe9, 0xe9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf4, 0xf4, 0xf4, 0xff, 0x54, 0x54, 0x54, 0xdc, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x3e, 0x3e, 0x3e, 0xe0, 0x54, 0x54, 0x54, 0xff, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x8e, 0x8e, 0x8e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb0, 0xb0, 0xb0, 0xff, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x4c, 0x4c, 0x4c, 0xd0, 0xec, 0xec, 0xec, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf4, 0xf4, 0xf4, 0xff, 0x53, 0x53, 0x53, 0xd8, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x1e, 0x1e, 0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xab, 0xab, 0xab, 0xff, 0xf6, 0xf6, 0xf6, 0xff, 0x80, 0x80, 0x80, 0xff, 0x31, 0x31, 0x31, 0xac, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x09, 0x09, 0x09, 0x03, 0x02, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x2e, 0x2e, 0x2e, 0xd7, 0x38, 0x38, 0x38, 0xc7, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

lv_image_dsc_t mouse_cursor_icon = {
    .header.magic = LV_IMAGE_HEADER_MAGIC,
    .header.w = 14,
    .header.h = 20,
    .data_size = 280 * 4,
    .header.cf = LV_COLOR_FORMAT_ARGB8888,
    .data = mouse_cursor_icon_map,
};

int panel_init()
{
	int ret = 0;
    int fd;
    int devno = 0;
    struct combo_dev_cfg_s *pst_dev_cfg = &dev_cfg_hx8394_720x1280;
    const struct dsc_instr *pst_dsc_instr = dsi_init_cmds_hx8394_720x1280;
    int dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_hx8394_720x1280);
    const struct hs_settle_s *pst_hs_settle = &hs_timing_cfg_hx8394_720x1280;

	fd = open(MIPI_TX_NAME, O_RDWR | O_NONBLOCK, 0);
	if (fd == -1) {
		printf("Cannot open '%s': %d, %s\n", MIPI_TX_NAME, errno, strerror(errno));
		return -1;
	}

	ret = CVI_MIPI_TX_Disable(fd);
	if (ret != 0) {
		printf("CVI_MIPI_TX_Disable fail!\n");
		return -1;
	}

	ret = CVI_MIPI_TX_Cfg(fd, pst_dev_cfg);
	if (ret != 0) {
		printf("CVI_MIPI_TX_Cfg fail!\n");
		return -1;
	}

	for (int i = 0; i < dsi_init_cmds_size; i++) {
		const struct dsc_instr *instr = &pst_dsc_instr[i];
		struct cmd_info_s cmd_info = {
			.devno = devno,
			.cmd_size = instr->size,
			.data_type = instr->data_type,
			.cmd = (void *)instr->data
		};

		ret = CVI_MIPI_TX_SendCmd(fd, &cmd_info);
		if (instr->delay)
			usleep(instr->delay * 1000);

		if (ret) {
			printf("dsi init failed at %d instr.\n", i);
			return ret;
		}
	}

	ret = CVI_MIPI_TX_SetHsSettle(fd, pst_hs_settle);
	if (ret != 0) {
		printf("CVI_MIPI_TX_SetHsSettle fail!\n");
		return -1;
	}

	ret = CVI_MIPI_TX_Enable(fd);
	if (ret != 0) {
		printf("CVI_MIPI_TX_Enable fail!\n");
		return -1;
	}

	printf("Init for MIPI-Driver-HX8394_EVB\n");

	close(fd);

    return 0;
}

int fb_init(void)
{
    struct fb_var_screeninfo vinfo = {0};
    struct fb_fix_screeninfo finfo = {0}; 

    memset(&vinfo, 0, sizeof(struct fb_var_screeninfo));
    memset(&finfo, 0, sizeof(struct fb_fix_screeninfo));

    // open device
    fbfd = open("/dev/fb0", O_RDWR);
    if (fbfd == -1) {
        printf("Error opening framebuffer device");
        return -1;
    }
    printf("The framebuffer device opened successfully.\n");

    // Get variable screen information
    ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo);
    printf("%dx%d, %dx%d, offset%dx%d, %dbpp, "
        "grayscale:%d, transp:%d,%d,%d, red:%d,%d,%d, green:%d,%d,%d, blue:%d,%d,%d.\n"
        , vinfo.xres, vinfo.yres
        , vinfo.xres_virtual, vinfo.yres_virtual
        , vinfo.xoffset, vinfo.yoffset
        , vinfo.bits_per_pixel
        , vinfo.grayscale
        , vinfo.transp.length, vinfo.transp.msb_right, vinfo.transp.offset
        , vinfo.red.length,    vinfo.red.msb_right,    vinfo.red.offset
        , vinfo.green.length,  vinfo.green.msb_right,  vinfo.green.offset
        , vinfo.blue.length,   vinfo.blue.msb_right,   vinfo.blue.offset);

    // Set variable screen information
    vinfo.xres = PANEL_WIDTH;
    vinfo.yres = PANEL_HEIGHT;
    vinfo.bits_per_pixel = BITS_PER_PIXEL;
    ioctl(fbfd, FBIOPUT_VSCREENINFO, &vinfo);

    ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo);
    printf("%dx%d, %dx%d, offset%dx%d, %dbpp, "
        "grayscale:%d, transp:%d,%d,%d, red:%d,%d,%d, green:%d,%d,%d, blue:%d,%d,%d.\n"
        , vinfo.xres, vinfo.yres
        , vinfo.xres_virtual, vinfo.yres_virtual
        , vinfo.xoffset, vinfo.yoffset
        , vinfo.bits_per_pixel
        , vinfo.grayscale
        , vinfo.transp.length, vinfo.transp.msb_right, vinfo.transp.offset
        , vinfo.red.length,    vinfo.red.msb_right,    vinfo.red.offset
        , vinfo.green.length,  vinfo.green.msb_right,  vinfo.green.offset
        , vinfo.blue.length,   vinfo.blue.msb_right,   vinfo.blue.offset);

    // Get fixed screen information
    ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo);
    printf("smem_len:%d, type:%d, type_aux:%d, "
        "visual:%d, xp:%d, yp:%d, yw:%d, line_length:%d, mmio_len:%d, accel:%d, cap:%d.\n"
        , finfo.smem_len
        , finfo.type, finfo.type_aux
        , finfo.visual
        , finfo.xpanstep, finfo.ypanstep, finfo.ywrapstep
        , finfo.line_length
        , finfo.mmio_len
        , finfo.accel
        , finfo.capabilities);

    return 0;
}

int fb_deinit(void)
{
    close(fbfd);

    return 0;
}

void mouse_read(lv_indev_t * indev, lv_indev_data_t * data)
{
    int readLen;
    int size = sizeof(struct input_event);
    struct input_event ev;
    struct timeval now;
    long elapsed;

    // 读取事件
    readLen = read(fd_mouse, &ev, size);
    if (readLen < size) {
        perror("read()");
        return ;
    }

    // 处理相对坐标事件
    if (ev.type == EV_REL) {
        if (ev.code == REL_X) {
            data->point.x += ev.value; // 水平移动
        } else if (ev.code == REL_Y) {
            data->point.y += ev.value; // 垂直移动
        }
    }

    // 获取鼠标按键状态
    if (ev.type == EV_KEY) {
        gettimeofday(&now, NULL);
        elapsed = (now.tv_sec - last_key_time.tv_sec) * 1000.0; // 秒转毫秒
        elapsed += (now.tv_usec - last_key_time.tv_usec) / 1000.0; // 微秒转毫秒

        if (elapsed > DEBOUNCE_TIME_MS) {
            if (ev.value == MOUSE_BTN_DOWN) { // 按键按下
                data->state = LV_INDEV_STATE_PR;
                printf("Mouse Button Pressed\n");
            } else if (ev.value == MOUSE_BTN_UP){ // 按键释放
                data->state = LV_INDEV_STATE_REL;
                printf("Mouse Button Released\n");
            }

            // 更新上一次按键事件的时间戳
            last_key_time = now;
        }
    }

    // 打印坐标
    // printf("position: %d, %d. \n", data->point.x, data->point.y);
}

int mouse_init(void)
{
    const char *device = "/dev/input/event0";

    indev_mouse = lv_evdev_create(LV_INDEV_TYPE_POINTER, device);
    if (indev_mouse == NULL) {
        printf("lv_evdev_create failed. \n");
        return -1;
    }

    // 设置鼠标光标
    // LV_IMG_DECLARE(mouse_cursor_icon);
    lv_obj_t * mouse_cursor = lv_image_create(lv_screen_active());
    lv_image_set_src(mouse_cursor, &mouse_cursor_icon);
    lv_indev_set_cursor(indev_mouse, mouse_cursor);

    return 0;
}

int mouse_deinit(void)
{
    lv_evdev_delete(indev_mouse);
    return 0;
}

// Function to write values to a file
int write_to_file(const char *path, const char *value)
{
    int fd = open(path, O_WRONLY);
    if (fd < 0)
    {
        perror("open");
        return -1;
    }

    if (write(fd, value, strlen(value)) < 0)
    {
        perror("write");
        close(fd);
        return -1;
    }

    close(fd);
    return 0;
}

// Function to build the sysfs path
void build_pwm_path(char *path, size_t size, int pwm_chip, int pwm_num, const char *file)
{
    snprintf(path, size, "/sys/class/pwm/pwmchip%d/pwm%d/%s", pwm_chip, pwm_num, file);
}

// Export PWM
int export_pwm(int pwm_chip, int pwm_num)
{
    char path[64];
    snprintf(path, sizeof(path), "/sys/class/pwm/pwmchip%d/export", pwm_chip);
    char buffer[3];
    snprintf(buffer, sizeof(buffer), "%d", pwm_num);
    return write_to_file(path, buffer);
}

// Set PWM period
int set_pwm_period(int pwm_chip, int pwm_num, const char *period)
{
    char path[64];
    build_pwm_path(path, sizeof(path), pwm_chip, pwm_num, "period");
    return write_to_file(path, period);
}

// Set PWM duty cycle
int set_pwm_duty_cycle(int pwm_chip, int pwm_num, const char *duty_cycle)
{
    char path[64];
    build_pwm_path(path, sizeof(path), pwm_chip, pwm_num, "duty_cycle");
    return write_to_file(path, duty_cycle);
}

// Enable or disable PWM
int enable_pwm(int pwm_chip, int pwm_num, int enable)
{
    char path[64];
    build_pwm_path(path, sizeof(path), pwm_chip, pwm_num, "enable");
    return write_to_file(path, enable ? "1" : "0");
}

// Function to validate PWM chip and channel numbers
int validate_pwm_numbers(int pwm_chip, int pwm_num)
{
    if ((pwm_chip != 0 && pwm_chip != 4 && pwm_chip != 8 && pwm_chip != 12) || (pwm_num < 0 || pwm_num > 3))
    {
        fprintf(stderr, "Invalid PWM chip or channel number. PWM chip must be 0, 4, 8, or 12, and channel number must be between 0 and 3.\n");
        return -1;
    }
    return 0;
}

int pwm_init(void)
{
    int ret;
    int pwm_chip = PWM_CHIP;
    int pwm_num = PWM_NUM;

    // Export the PWM channel
    ret = export_pwm(pwm_chip, pwm_num);
    if (ret < 0)
    {
        fprintf(stderr, "Error exporting PWM%d on pwmchip%d\n", pwm_num, pwm_chip);
    }

    // Set the period
    ret = set_pwm_period(pwm_chip, pwm_num, "100");
    if (ret < 0)
    {
        fprintf(stderr, "Error setting the period for PWM%d on pwmchip%d\n", pwm_num, pwm_chip);
        return -1;
    }

    // Set the duty cycle
    ret = set_pwm_duty_cycle(pwm_chip, pwm_num, "80");
    if (ret < 0)
    {
        fprintf(stderr, "Error setting the duty cycle for PWM%d on pwmchip%d\n", pwm_num, pwm_chip);
        return -1;
    }

    // Enable PWM
    ret = enable_pwm(pwm_chip, pwm_num, 1);
    if (ret < 0)
    {
        fprintf(stderr, "Error enabling PWM%d on pwmchip%d\n", pwm_num, pwm_chip);
        return -1;
    }

    return 0;
}

int pwm_deinit(void)
{
    return 0;
}

static void slider_event_cb(lv_event_t * e)
{
    int ret;
    char str_num[20];

    lv_obj_t * slider = lv_event_get_target(e);
    int32_t v = lv_slider_get_value(slider);
    // printf(">>>>>>>>>>>>>> v:%d. \n", v);

    sprintf(str_num, "%d", v);

    // Set the duty cycle
    ret = set_pwm_duty_cycle(PWM_CHIP, PWM_NUM, str_num);
    if (ret < 0)
    {
        fprintf(stderr, "Error setting the duty cycle.\n");
    }
}

int main(void)
{
    panel_init();
    fb_init();
    lv_init();

    /*Linux frame buffer device init*/
    lv_display_t * disp = lv_linux_fbdev_create();
    lv_linux_fbdev_set_file(disp, "/dev/fb0");
    lv_linux_fbdev_set_force_refresh(disp, true);

    mouse_init();
    pwm_init();

#if 0
    // 多页面窗口切换
    lv_demo_widgets();
    lv_demo_widgets_start_slideshow();
#endif
#if 0
    // 矢量静态图形demo
    lv_demo_vector_graphic();
#endif
#if 0
    // 滑动条（圆弧，直线）
    lv_demo_transform();
#endif
#if 0
    // 压力测试
    lv_demo_stress();
#endif
#if 0
    // 列表开关
    lv_demo_scroll();
#endif
#if 0
    // 音乐播放器
    lv_demo_music();
#endif
#if 0
    // 多选项卡
    lv_demo_multilang();
#endif
#if 0
    // 键盘、编码器
    lv_demo_keypad_encoder();
#endif
#if 0
    // 测试
    lv_demo_benchmark();
#endif
#if 0
    // 多层页面
    lv_demo_flex_layout();
#endif

    // 创建滑动条
    lv_obj_t * slider = lv_slider_create(lv_screen_active());
    lv_obj_set_width(slider, lv_pct(70));
    lv_obj_align(slider, LV_ALIGN_BOTTOM_MID, 0, -20);
    lv_obj_add_event_cb(slider, slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL);
    lv_slider_set_range(slider, 0, 100);
    lv_slider_set_value(slider, 80, LV_ANIM_ON);

    /*Handle LVGL tasks*/
    while(1) {
        lv_task_handler();
        usleep(5000);
    }

    pwm_deinit();
    mouse_deinit();

    fb_deinit();
    return 0;
}
